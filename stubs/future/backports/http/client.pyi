import io
from future.backports.email import message as email_message
from typing import Any, Optional

responses: Any

class HTTPMessage(email_message.Message):
    def getallmatchingheaders(self, name: Any): ...

class HTTPResponse(io.RawIOBase):
    fp: Any = ...
    debuglevel: Any = ...
    headers: Any = ...
    version: Any = ...
    status: Any = ...
    reason: Any = ...
    chunked: Any = ...
    chunk_left: Any = ...
    length: Any = ...
    will_close: Any = ...
    def __init__(self, sock: Any, debuglevel: int = ..., strict: Any = ..., method: Optional[Any] = ..., url: Optional[Any] = ...) -> None: ...
    code: Any = ...
    def begin(self) -> None: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def readable(self): ...
    def isclosed(self): ...
    def read(self, amt: Optional[Any] = ...): ...
    def readinto(self, b: Any): ...
    def fileno(self): ...
    def getheader(self, name: Any, default: Optional[Any] = ...): ...
    def getheaders(self): ...
    def __iter__(self) -> Any: ...
    def info(self): ...
    def geturl(self): ...
    def getcode(self): ...

class HTTPConnection:
    response_class: Any = ...
    default_port: Any = ...
    auto_open: int = ...
    debuglevel: int = ...
    timeout: Any = ...
    source_address: Any = ...
    sock: Any = ...
    def __init__(self, host: Any, port: Optional[Any] = ..., strict: Any = ..., timeout: Any = ..., source_address: Optional[Any] = ...) -> None: ...
    def set_tunnel(self, host: Any, port: Optional[Any] = ..., headers: Optional[Any] = ...) -> None: ...
    def set_debuglevel(self, level: Any) -> None: ...
    def connect(self) -> None: ...
    def close(self) -> None: ...
    def send(self, data: Any) -> None: ...
    def putrequest(self, method: Any, url: Any, skip_host: int = ..., skip_accept_encoding: int = ...) -> None: ...
    def putheader(self, header: Any, *values: Any) -> None: ...
    def endheaders(self, message_body: Optional[Any] = ...) -> None: ...
    def request(self, method: Any, url: Any, body: Optional[Any] = ..., headers: Any = ...) -> None: ...
    def getresponse(self): ...

class HTTPSConnection(HTTPConnection):
    default_port: Any = ...
    key_file: Any = ...
    cert_file: Any = ...
    def __init__(self, host: Any, port: Optional[Any] = ..., key_file: Optional[Any] = ..., cert_file: Optional[Any] = ..., strict: Any = ..., timeout: Any = ..., source_address: Optional[Any] = ..., **_3to2kwargs: Any) -> None: ...
    sock: Any = ...
    def connect(self) -> None: ...

class HTTPException(Exception): ...
class NotConnected(HTTPException): ...
class InvalidURL(HTTPException): ...

class UnknownProtocol(HTTPException):
    args: Any = ...
    version: Any = ...
    def __init__(self, version: Any) -> None: ...

class UnknownTransferEncoding(HTTPException): ...
class UnimplementedFileMode(HTTPException): ...

class IncompleteRead(HTTPException):
    args: Any = ...
    partial: Any = ...
    expected: Any = ...
    def __init__(self, partial: Any, expected: Optional[Any] = ...) -> None: ...

class ImproperConnectionState(HTTPException): ...
class CannotSendRequest(ImproperConnectionState): ...
class CannotSendHeader(ImproperConnectionState): ...
class ResponseNotReady(ImproperConnectionState): ...

class BadStatusLine(HTTPException):
    args: Any = ...
    line: Any = ...
    def __init__(self, line: Any) -> None: ...

class LineTooLong(HTTPException):
    def __init__(self, line_type: Any) -> None: ...
error = HTTPException
